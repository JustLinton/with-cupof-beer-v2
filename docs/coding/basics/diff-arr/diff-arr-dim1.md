# 一维差分

#### 时间复杂度

更新O(1)，求更新后的原数组O(n)。

#### 思想

- 差分实际上是前缀和的逆运算。意思就是，现在给定了数组`a[n]`，那么现在把这个a数组**看成是某个数组的前缀和**。因为看成了前缀和，所以要求输入的这个数组a的下标仍然是**从1开始的**，因为0下标的元素必须是0.
- 设那个数组为`diff[n]`。根据前缀和的定义，可知`diff[0]`无意义。那么如何求这个`diff`数组的各项呢？那就可以使用前缀和求项的公式，也就是得到`diff[i]=a[i]-a[i-1]`。
- 作用是可以用来在O(1)的时间内对一段区间内的所有元素进行相同的加减操作，也就是同时都加上或减去一个数字。原理以都`+c`为例。考虑如果让`diff[i]+=c`，因为`a`数组是`diff`数组的前缀和，所以导致`a`数组的从下标`i`到下标`n`（`n`是`a`数组的`size`）都`+=c`了。如果我们要求只是某个区间`+c`，例如`[i,j]`上，那么就需要让`j`之后的都不要再`+c`了。此时可以让`diff[j+1]-=c`，就把前面加上的那个c抵消了。这就达到了目的。
- 如何导出我们一顿操作猛如虎后的新的`a`数组？利用前缀和的定义即可。因为`diff`被看做了原数组，而`a`数组是他的前缀和，所以只需要`a[i]=a[i-1]+diff[i]=diff[1]+...+diff[i]`.

#### 模板
- 注意，一开始在输入的时候是要求一下差分数组的！！！！！即`dff[i]=a[i]-a[i-1]`！
- 由于`dff[i]=a[i]-a[i-1]`，所以`a[i]=dff[i]+a[i-1]`（实际上就是把求差分的公式做了一下**移项**）.注意，需要真的这样去依次更新a[i]！而且如果由小到大更新，则只能由小到大输出。因为结果的正确性完全基于前面的a[i]是否被正确更新了（这就有点像动态规划。你前面的结果是对的，你后面的结果才是对的）。