# KMP

!!! beer-tips "浅记" 
    KMP是一种速度达到$O(n)$的字符串匹配算法，可以完成模式匹配的任务。给定一个长串和一个模式串，它可以返回模式串匹配成功的所有位置。

#### 基本思想
- 如何设法利用之前的结果？一个思想就是不要每次都从模式串的开头重新匹配，而是设法从失败的地方后退几步，然后再那个地方继续开始匹配。
!!! quote "结论" 
    当发现不可能成功的时候不要硬刚，而是要曲线救国。就像追妹子，如果发现不可取可以后退几步重新尝试，这样就不至于从头再来。

!!! beer-tips inline end "浅记" 
    注意，后退几步指的是模式串当前匹配成功的下标变小了。

- 如何科学地后退几步？关键要确定要后退到哪个地方。
- 我们需要保证后退后，当前已经匹配成功的字符串部分仍然能与当前情况下的目标串部分保持刚才的匹配关系。

#### 预处理
- 预处理，就是为**合理后退**创造条件。
- 设`next[i]`数组，表示**模式串**中长度为i的子串`[1,i]`中，包含的前缀、后缀完全相等的这样的前缀或后缀的最大长度。
	- 前缀的意思是从字符串第一个字符开始的子串；后缀的意思是以字符串的最后一个字符结束的子串。他们相等意味着长度也一致，这就是为什么上面说“或”。
- 这样的思想有一点像动态规划，但是它不会利用到前面子问题的答案。所谓“像动态规划”，是因为我们把i定义成了子串的长度，且我们按i递增的顺序进行求解。
- 求出了这样的`next[i]`数组，我们预处理就结束了。

#### 串匹配
- 假设我们现在的情况是：
	- 子串已经匹配到了j下标，也就是子串的`[0,j]`都是匹配成功的；
	- 目的串已经匹配到了`i-1`下标，也就是目标串的`[(i-1-j)+1,i-1]`的部分已经匹配上了；
	- 现在我们要开始匹配目的串的第i个字符，也就是模式串的第`j+1`个字符。
- 然后我们突然发现目的串的字符i和模式串的字符`j+1`不相等。此时应该进行倒退。具体做法是j移动到`next[j]`处即可。
!!! beer-tips inline "浅记" 
    “匹配进度的倒退”的意思是，模式串整体向下标增大的方向平移。但是目的串不动，所以看似模式串向前移动了，但是j却减小了，这就是为什么称为“倒退”。

- 移动了j后，重新开始匹配。如果发现仍然寸步难行，就继续执行上述操作，所以这个过程又被称为**递归后退**。
- 如果后退到一定程度，发现后面真的能完全匹配了，输出结果。进行下一轮匹配。