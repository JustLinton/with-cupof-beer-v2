# 静态哈希表

!!! beer-tips "浅记" 
    哈希表可以把很大范围的数据映射到较小长度的数组中存放。离散化实际上就是一种特殊的哈希表；一般，在算法题中，哈希表不存在删除操作。只有增、查。

- 如果题目真的要求要删除，那就相当于查找。对于开放定址法而言，就是查找到正确的位置，然后打一个标记，表示已失效。
#### 数据结构
- `h[i]`数组，就是哈希表本表了。这里用数组模拟了哈希表。每个元素就是一个桶。
- 如果采用拉链法，还需要`e[i],ne[i],idx`，这是静态链表的结构。
- 如果采用开放寻址法，只需要`h[i]`数组即可。但是长度要开3倍以上，**否则一旦满了我们的代码就死循环了。**

#### 取模哈希函数
- **数学上可以证明**，如果采用取模作为哈希函数，则应当模一个质数，且这个质数尽量离2的整数次幂远一些。
- 一般情况下，槽个数和模数相等。**所以槽的个数也是那个质数**。

#### 拉链法解决冲突
- 桶不放元素值了，而是直接当做链表头。而桶内的元素，则是指向链表第一个结点的指针。也就是我们静态链表中，那个结点下标。

!!! beer-tips inline end "浅记" 
    这里先模N再加N的原因是，如果直接+N，并不能保证加到正数。如果N比x的范围小得多，例如N是哈希表桶的个数，x是数据，就会出现问题。整个一通操作，只是为了正确给负数取模。

- 因为在平均情况下，拉链法拉出的链基本上都**不算太长**，所以哈希表的查找复杂度是 $O(1)$近似。
- 这里，每个桶被当成了链表头，也就是说桶里面并不真正存元素值，而是存链表第一个结点的idx。每次插入新结点时，相当于在链表头和第一个元素之间插入了新节点。
- 这里，k是key，即算出的桶编号。
``` c++ title="拉链法插入" hl_lines="3" 

void insert(int x){
	int k=(x%N+N)%N;
	
	e[idx]=x;
	ne[idx]=h[k];
	h[k]=idx++;
}

```
- 如果要判断是否存在，只需要遍历映射到的桶下面挂的那个链表即可。
``` c++ title="拉链法查找" hl_lines="0" 

bool find(int x){
	int k=(x%N+N)%N;
	
	for(int i=h[k];i!=-1;i=ne[i])
		if(e[i]==x)return true;
		
	return false;
}

```

#### 开放寻址法解决冲突
- 一般经验表明，桶的个数开到正常桶个数的2-3倍，可以显著降低冲突几率。例如题目需要100000个桶，我们开到300000即可显著提升效率了。
- 可以理解为上厕所蹲坑。我想去的坑如果没人，就直接进去；如果有人，就找下一个坑，以此类推，直到找到空的坑。

!!! beer-tips inline end "浅记" 
    开放寻址法是以find方法为中心的，因为这里的find，如果输入k，可以返回k的位置或是第一个可以放k的位置。可以判断一下，如果返回值是`null`，那就是没找到；否则是找到了。**之所以允许这么做，是因为哈希表要求key唯一。**

- 这里，事先已经利用`memset(arr,0x3f,sizeof(arr))`，把数组初始化为元素都是`0x3f3f3f3f`，这是一个**略大于**数据范围的数字，所以可以用来判空，如下高亮代码。
``` c++ title="开放定址法的find" hl_lines="7" 

const int null = 0x3f3f3f3f;

int find(int x){
	int k=(x%N+N)%N;

	while(h[k]!=null&&h[k]!=x){
		k++;
		if(k==N)k=0;//如果找到头了，就再回到0处，就像电梯算法那样
	}
	
	return k;
}
```

- 因为find除了返回k的位置，还可以返回第一个可以放k的位置，所以可以直接调用find进行插入操作，如下。

``` c++ title="开放定址法的insert" hl_lines="3" 

void insert(int k){
	int idx=find(k);
	h[idx]=k;
}

```