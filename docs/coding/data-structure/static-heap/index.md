# 静态堆

!!! beer-tips "浅记" 
    如何手撕一个堆？

#### 数据结构
- 堆是一个**完全二叉树**。小根堆的意思是：每个结点的值**都小于等于其俩儿子**。
	- 为什么堆的根节点最小？因为根节点肯定是小于等于其俩儿子的，但是俩儿子又是以他们为根的子树的最小值，所以根节点是整棵树的最小值。
- 可以用数组存储一棵二叉树。则对于下标x，它的左儿子是`2x`，右儿子是`2x+1`.
- 用`size`整数来表示堆的大小，作用类似于静态数据结构中的`idx`。但是区别是，这里需要进行内存回收，从而让它满足找儿子算法。否则如果其中有很多碎片，找儿子算法就失效了。
- 注意，数组下标从1开始。这是为了统一找儿子的算法。
#### 下移操作
!!! beer-tips inline end "浅记" 
    如果我们把某个节点的值变大了，就需要把它往下移以满足堆结构。

- 如果元素出现的位置比期望的更高，也就是它的值相对于这个位置来说**太大**了，就需要**下移**。
- 可以比较这个结点、其左儿子、其右儿子**这三者**的大小关系，让这个结点和较小的那个儿子交换位置。
- 递归进行这个步骤，直到无法满足交换条件，或到达叶结点。

``` c++ title="把下标是u的结点进行下移操作" hl_lines="0" 
void down(int u){
	int t=u;
	if(u*2<=size&&heap[u*2]<heap[t])t=u*2;
	if(u*2+1<=size&&heap[u*2+1]<heap[t])t=u*2+1;
	if(t!=u){
		swap(heap[t],heap[u]);
		down(t);
	}
}
```

- 其中，t的作用是记录三者中最小的那个。所以，注意条件判断里是 `heap[t]`而不是`heap[u]`.
- 这是递归下移。而且这个递归没有必要改成迭代，因为层数是log的，问题不大。

#### 上移操作
!!! beer-tips inline "浅记" 
    如果我们把某个节点变小了，就需要把它往上移以满足堆结构。

- 如果元素过小，那么所处的位置对他来说太靠下了。
- 可以比较该结点、其父亲结点**这两者**的大小关系。如果他比父节点小，就交换。
- 递归进行，直到不满足交换条件，或到达根节点。

``` c++ title="把下标是u的结点进行上移操作" hl_lines="0" 

void up(int u){
	while(u/2&&heap[u/2]>h[u])swap(heap[u],heap[u/2]);
	u/=2;
}

```

- up操作比较简单，只需要迭代写法即可完成。

#### 基本操作
| 操作     | 算法 |
| -------- | ---- |
| 插入元素 |   `heap[size++]=x; up(size);`   |
| 删除最小元素 |   `heap[1]=heap[size]; size--; down(1);`   |
|        求最小元素  |   `heap[1];`   |

#### 任意操作
!!! beer-tips inline "浅记" 
    删除任意、修改任意就是我们手撕的好处。因为这两个操作不能在STL堆中完成。

| 操作         | 算法 |
| ------------ | ---- |
| 删除任意元素 | `heap[k]=heap[size]; size--; down(k) ;up(k);`     |
| 修改任意元素             |   `heap[k]=x; down(k); up(k);`   |

- 注意为什么要`down()`、`up()`都写上。因为删除任意元素，是用数列尾部元素去取代中间位置的元素，而不是根元素，因此我们不知道它所处的位置是过高了还是过低了。同理，如果要修改元素，因为是任意位置，我们同样不知道是过高还是过低。
- 虽然两者都写了，但是实际上只有一个会被执行。