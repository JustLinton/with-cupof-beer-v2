# 路径压缩

!!! beer-tips "浅记" 
    相较于非路径压缩算法，加了压缩才能体现并查集的优越性。否则复杂度和暴力没有区别。这里，路径压缩算法和普通求代表元算法的区别是：路径压缩是递归的。
    
每次查找x的集合代表元的时候，如果找到了这个代表元，就让这向根节点查找的整条路径上的元素的父亲都改成该代表元。于是，以后只要查找这条路上的任意元素的集合代表元，复杂度都变成了完全 $O(1)$.

!!! beer-tips inline "浅记" 
    到了根节点时，return的是代表元；这个return的值给了上一层递归的`p[x]`，而上一层递归又继续返回`p[x]`，其值是刚才返回的代表元.... 以此类推，可以实现递归地设置这一条路上的所有结点的p都是代表元。

``` c++ title="" hl_lines="0" 
int find(int x){
	if(p[x]!=x)p[x]=find(p[x]);
	return p[x];
}
```

