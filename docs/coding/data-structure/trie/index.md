# Trie树🌲

!!! beer-tips "浅记" 
    Trie树，读作“串儿树”或是“踹树”，可以实现数量很大的字符串集合的高效存储和快速查找。

#### 数据结构
- 二维数组`son[i][26]`，表示下标是i的结点的孩子情况。例如i结点有孩子c，那么 `son[i]['c'-26]=p`，这里p是那个孩子结点的下标。
- 一维数组`cnt[i]`，表示有多少个以下标是i的结点为结尾的字符串。
- 整数`idx`和静态链表中的作用一样，用于静态内存的动态管理，表示当前可用的新结点的下标。

#### 插入字符串
- 例如给一个字符串`adcbe`，则可以从根节点开始，依次创建以元素a、d、c、b、e为值的结点即可。后者是前者的儿子。然后记录以这个e结点结束的字符串数量++；
- 如果还要插入一个字符串`adcf`，则可以从根节点开始查询，然后走到c发现它没有f孩子，就可以创建一个f孩子，并记录以这个f结点结束的字符串数量++；
- 如果又要插入一个字符串`adc`，则还是从根节点开始，依次查找到c处，发现一路畅通无阻，可以直接让这个c结点结束的字符串数量++；
- 若是插入字符串`bdcbe`，会发现根节点就没有以b为值的孩子，于是创建b；然后显然这个b没有以d为值的孩子，继续一路创建下去，最后让这一条路上的e结点结束的字符串数量++；

#### 查找字符串
!!! beer-tips inline end "浅记" 
    这里总是强调“该”b结点，“该”e结点，是因为这棵Trie树上可以有任意多个值相同的结点。因为总节点数量可以任意，但是字母却只有26或52个。因此，我们只能用结点下标来唯一标识一个节点。

- 例如在刚才的Trie树上查找`adcbe`，则从根节点出发发现有儿子a，a有儿子b，一直找下去发现有儿子e，且存在以该e结点为结束的字符串，查找成功；
- 若查找`adce`，则找到c发现没有e儿子，查找失败；
- 若查找`adcb`，则从根节点找到b，一路畅通无阻，但是因为并没有以这个b结点为结束的字符串记录，所以查找失败。