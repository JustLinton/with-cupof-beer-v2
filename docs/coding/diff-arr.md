# 差分

## 一维差分

#### 时间复杂度

更新O(1)，求更新后的原数组O(n)。

#### 思想

- 差分实际上是前缀和的逆运算。意思就是，现在给定了数组`a[n]`，那么现在把这个a数组**看成是某个数组的前缀和**。因为看成了前缀和，所以要求输入的这个数组a的下标仍然是**从1开始的**，因为0下标的元素必须是0.
- 设那个数组为`diff[n]`。根据前缀和的定义，可知`diff[0]`无意义。那么如何求这个`diff`数组的各项呢？那就可以使用前缀和求项的公式，也就是得到`diff[i]=a[i]-a[i-1]`。**事实上，这个式子只是用来定义什么是差分数组。我们在应用中无需去构造整个差分数组，而只需要考虑中途更新，和最后输出结果的时候还原原数组即可。**
- 作用是可以用来在O(1)的时间内对一段区间内的所有元素进行相同的加减操作，也就是同时都加上或减去一个数字。原理以都`+c`为例。考虑如果让`diff[i]+=c`，因为`a`数组是`diff`数组的前缀和，所以导致`a`数组的从下标`i`到下标`n`（`n`是`a`数组的`size`）都`+=c`了。如果我们要求只是某个区间`+c`，例如`[i,j]`上，那么就需要让`j`之后的都不要再`+c`了。此时可以让`diff[j+1]-=c`，就把前面加上的那个c抵消了。这就达到了目的。
- 如何导出我们一顿操作猛如虎后的新的`a`数组？利用前缀和的定义即可。因为`diff`被看做了原数组，而`a`数组是他的前缀和，所以只需要`a[i]=a[i-1]+diff[i]=diff[1]+...+diff[i]`.

## 二维差分

#### 思想

- 仍然考虑一个原点在左上角的坐标系，沿着右、下方向是坐标数值增加的方向。则如果要让左上角顶点`(k,l)`，右下角顶点`(i,j)`的矩形中的元素都`+=c`，则需要让`diff[k][l]+=c,diff[k,j]-=c,diff[i,l]-=c,diff[i,j]+=c`。因为当`diff[k][l]+=c`，就会导致点`(k,l)`为左上角顶点，以数组大小为右下角顶点的广阔区域都`+=c`。我们借鉴一维差分的思想，让`diff[k,j],diff[i,l]`减回来这个`c`。但是显然以`(i,j)`为左上角顶点，以数组大小为右下角顶点的广阔区域一共被加了1个`c`，减去了两个`c`，所以还需要加回来一个`c`，也就是`diff[i][j]+=c`.
