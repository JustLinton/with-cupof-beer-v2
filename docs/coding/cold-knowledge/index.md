# 冷知识🧊

#### printf和cout，scanf和cin的效率差别
- 实测，运行同一个题目，前者用了120ms，后者用了1430ms。

#### 静态数据结构和STL数据结构的效率差别
- 实测，前者效率是后者的两倍以上，所以尽量自己写数据结构。

#### 数据范围
- 算法竞赛中，数据范围一般默认 $10^6$，也就是拉到极限。

#### 背模板是打算法竞赛的唯一出路
- 做物理题的时候不可能手动推导牛顿三定律。

#### 读入字符
- 读入字符也尽量使用`%s`，因为如果出题人不小心多了个回车，你那getchar就当场`gg`。

#### 如何正确对负数进行取模
!!! beer-tips inline end "浅记" 
    这里先模N再加N的原因是，如果直接+N，并不能保证加到正数。如果N比x的范围小得多，例如N是哈希表桶的个数，x是数据，就会出现问题。

- 在C++中，负数的模仍然是负数。例如$-10/3=-3$,那么有$-10-(-3)\times 3=-10+9=-1$，所以在C++中，$-10 mod 3 =-1$.
- 但是在数学上，-10对3取模应该是2.所以在C++中如果对负数进行正确取模，应该模N+N再整体模N。即：`m=(x%N+N)%N`.

#### 关于0x3f3f3f3f
!!! beer-tips inline "浅记" 
    因为`memset`是按字节进行内存初始化。一个`int`是4个字节，所以只需要给定`0x3f`，我们就可以让每个数都是`0x3f3f3f3f`了。因为它被**复制**了四遍。因此，memset一般只能用作0，-1，或是0x3f这种特殊的循环数。同样的，`memcpy`也是按字节复制，因为char一般是1字节，所以大家用起来就很舒服。

- 为什么这么喜欢写`0x3f3f3f3f`？因为它大于$10^9$，是`1061109567`但是又没大出太多去，即不至于爆`int`。
- 再综合`memset`的原理，于是得到骚操作：如果使用 `memset(arr,0x3f,sizeof(arr))`，就可以把数组初始化为最大值填充，也就是数组的每个元素都是`0x3f3f3f3f`.